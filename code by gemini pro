# -----------------------------------------------------------------------------
# High-Performance PID Line Follower for Raspberry Pi Pico
#
# Author: Expert Robotics Engineer
# Date: 2024-10-27
#
# Description:
# This MicroPython script implements a PID (Proportional-Integral-Derivative)
# control algorithm for a line-following robot based on the Raspberry Pi Pico.
# It is designed for a 2-wheel robot using a TB6612FNG motor driver and a
# 5-channel digital IR reflectance sensor array.
#
# Hardware:
# - Raspberry Pi Pico
# - TB6612FNG Dual Motor Driver
# - 5-Channel IR Sensor Array (Digital Output)
# - 2x DC Motors
# - Power source (e.g., 2S LiPo battery) with MP1584 buck converter
#
# The code is structured for clarity, performance, and ease of tuning.
# -----------------------------------------------------------------------------

from machine import Pin, PWM
import utime

# --- Pin Definitions (as per Master Pinout Configuration Table) ---
# Motor A (e.g., Left Motor)
AIN1_PIN = 10
AIN2_PIN = 11
PWMA_PIN = 12

# Motor B (e.g., Right Motor)
BIN1_PIN = 13
BIN2_PIN = 14
PWMB_PIN = 15

# Motor Driver Standby Pin
STBY_PIN = 28

# IR Sensor Pins (from left to right)
SENSOR_1_PIN = 18  # Outermost Left
SENSOR_2_PIN = 19  # Inner Left
SENSOR_3_PIN = 20  # Center
SENSOR_4_PIN = 21  # Inner Right
SENSOR_5_PIN = 22  # Outermost Right

# --- PID Controller and Robot Parameters ---
# IMPORTANT: These gains (KP, KI, KD) are the most critical values to tune.
# Start with KI and KD = 0 and tune KP first.
KP = 0.4          # Proportional gain
KI = 0.001        # Integral gain
KD = 0.3          # Derivative gain

# Base speed of the robot (0.0 to 1.0).
# This is the speed when the robot is perfectly on the line.
BASE_SPEED = 0.6

# --- Motor Control Class for TB6612FNG ---
class TB6612FNG:
    """
    A class to control a single DC motor using the TB6612FNG driver.
    """
    def __init__(self, in1_pin, in2_pin, pwm_pin):
        """
        Initializes the motor control pins.
        """
        self.in1 = Pin(in1_pin, Pin.OUT)
        self.in2 = Pin(in2_pin, Pin.OUT)
        self.pwm = PWM(Pin(pwm_pin))
        self.pwm.freq(1000)  # Set PWM frequency (1kHz is common)

    def drive(self, speed):
        """
        Drives the motor at a given speed.
        :param speed: A float from -1.0 (full reverse) to 1.0 (full forward).
        """
        # Clamp speed to the valid range [-1.0, 1.0]
        if speed > 1.0:
            speed = 1.0
        elif speed < -1.0:
            speed = -1.0

        if speed > 0:
            # Forward motion
            self.in1.value(1)
            self.in2.value(0)
            duty_cycle = int(speed * 65535)
        elif speed < 0:
            # Reverse motion
            self.in1.value(0)
            self.in2.value(1)
            duty_cycle = int(abs(speed) * 65535)
        else:
            # Stop (coast)
            self.in1.value(0)
            self.in2.value(0)
            duty_cycle = 0
            
        self.pwm.duty_u16(duty_cycle)

    def stop(self):
        """
        Coasts the motor to a stop.
        """
        self.drive(0)

    def brake(self):
        """
        Applies a brake to the motor (short circuit).
        """
        self.in1.value(1)
        self.in2.value(1)
        self.pwm.duty_u16(0)

# --- Hardware Initialization ---
# Initialize motor driver standby pin and set it high to enable the driver
stby = Pin(STBY_PIN, Pin.OUT)
stby.value(1)

# Create motor objects
motor_left = TB6612FNG(AIN1_PIN, AIN2_PIN, PWMA_PIN)
motor_right = TB6612FNG(BIN1_PIN, BIN2_PIN, PWMB_PIN)

# Initialize sensor pins as inputs
sensor_pins =

# Sensor weights for calculating the weighted average error
# More negative means line is to the left, more positive means to the right.
sensor_weights = [-4, -2, 0, 2, 4]

# --- PID Control Variables ---
integral = 0
last_error = 0
last_known_position = 0

# --- Main Control Loop ---
print("Starting line follower...")
while True:
    # 1. Read sensor values
    # A value of 1 means the sensor is on the black line.
    sensor_values = [pin.value() for pin in sensor_pins]
    
    # 2. Calculate positional error using a weighted average
    error = 0
    active_sensors = sum(sensor_values)
    
    if active_sensors > 0:
        # Calculate the weighted average of the sensor readings
        weighted_sum = 0
        for i in range(len(sensor_values)):
            weighted_sum += sensor_weights[i] * sensor_values[i]
        
        error = weighted_sum / active_sensors
        last_known_position = error
    else:
        # If no sensors see the line, use the last known position
        # to guess where the line is.
        if last_known_position > 2: # Was far right
             error = 5
        elif last_known_position < -2: # Was far left
             error = -5
        else: # Was near center, assume it's a gap
             error = 0

    # 3. PID Calculation
    # Proportional term
    proportional = KP * error
    
    # Integral term
    integral += KI * error
    # Anti-windup: Clamp the integral term to prevent it from growing too large
    integral = max(min(integral, 1.0), -1.0)
    
    # Derivative term
    derivative = KD * (error - last_error)
    
    # 4. Compute the correction value
    correction = proportional + integral + derivative
    
    # 5. Adjust motor speeds based on the correction
    left_speed = BASE_SPEED - correction
    right_speed = BASE_SPEED + correction
    
    # Clamp motor speeds to the valid range [-1.0, 1.0]
    left_speed = max(min(left_speed, 1.0), -1.0)
    right_speed = max(min(right_speed, 1.0), -1.0)
    
    # 6. Drive the motors
    motor_left.drive(left_speed)
    motor_right.drive(right_speed)
    
    # 7. Update last_error for the next iteration
    last_error = error
    
    # Optional: Print debug information
    # print(f"Sensors: {sensor_values} | Error: {error:.2f} | Correction: {correction:.2f} | L: {left_speed:.2f} R: {right_speed:.2f}")

    # 8. Loop delay to control the frequency of the PID loop
    utime.sleep_ms(10)
