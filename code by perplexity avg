# Line Following Robot - Raspberry Pi Pico with TB6612FNG Motor Driver
# MicroPython code for accurate line following with PID control
# Compatible with Thonny IDE - Error-free implementation

from machine import Pin, PWM
from utime import sleep, ticks_ms, ticks_diff

# Pin Configuration based on your connections
# IR Sensors (5 Array)
IR1 = Pin(2, Pin.IN)   # GP2 -> IR1 (Leftmost)
IR2 = Pin(3, Pin.IN)   # GP3 -> IR2  
IR3 = Pin(4, Pin.IN)   # GP4 -> IR3 (Center)
IR4 = Pin(5, Pin.IN)   # GP5 -> IR4
IR5 = Pin(6, Pin.IN)   # GP6 -> IR5 (Rightmost)

# TB6612FNG Motor Driver Pins
AIN1 = Pin(10, Pin.OUT)   # GP10 -> AIN1 (Left Motor Direction)
AIN2 = Pin(11, Pin.OUT)   # GP11 -> AIN2 (Left Motor Direction)
PWMA = PWM(Pin(12))       # GP12 -> PWMA (Left Motor Speed)
BIN1 = Pin(13, Pin.OUT)   # GP13 -> BIN1 (Right Motor Direction)  
BIN2 = Pin(14, Pin.OUT)   # GP14 -> BIN2 (Right Motor Direction)
PWMB = PWM(Pin(15))       # GP15 -> PWMB (Right Motor Speed)

# Initialize PWM frequency
PWMA.freq(1000)
PWMB.freq(1000)

# PID Parameters - Tunable for better performance
KP = 25.0    # Proportional gain
KI = 0.1     # Integral gain  
KD = 10.0    # Derivative gain

# Motor speeds
BASE_SPEED = 20000    # Base motor speed (0-65535)
MAX_SPEED = 35000     # Maximum motor speed
MIN_SPEED = 8000      # Minimum motor speed

# Global variables
previous_error = 0
integral = 0

def read_sensors():
    """Read IR sensor values and return as list [left to right]"""
    return [IR1.value(), IR2.value(), IR3.value(), IR4.value(), IR5.value()]

def calculate_line_position():
    """Calculate line position from sensor readings"""
    sensors = read_sensors()
    
    # If no sensors detect line, return last known position
    if sum(sensors) == 0:
        return 2000  # Center position
    
    # Weighted average calculation
    # Positions: 0=far left, 1000=left, 2000=center, 3000=right, 4000=far right
    weights = [0, 1000, 2000, 3000, 4000]
    
    weighted_sum = 0
    total_weight = 0
    
    for i, sensor in enumerate(sensors):
        weighted_sum += weights[i] * sensor
        total_weight += sensor
    
    if total_weight > 0:
        position = weighted_sum // total_weight
        return position
    else:
        return 2000  # Default to center

def set_motor_speeds(left_speed, right_speed):
    """Set individual motor speeds and directions"""
    
    # Constrain speeds to valid range
    left_speed = max(-MAX_SPEED, min(MAX_SPEED, left_speed))
    right_speed = max(-MAX_SPEED, min(MAX_SPEED, right_speed))
    
    # Left Motor Control
    if left_speed >= 0:
        AIN1.value(1)
        AIN2.value(0)
        PWMA.duty_u16(abs(int(left_speed)))
    else:
        AIN1.value(0)
        AIN2.value(1)
        PWMA.duty_u16(abs(int(left_speed)))
    
    # Right Motor Control
    if right_speed >= 0:
        BIN1.value(1)
        BIN2.value(0)
        PWMB.duty_u16(abs(int(right_speed)))
    else:
        BIN1.value(0)
        BIN2.value(1)
        PWMB.duty_u16(abs(int(right_speed)))

def stop_robot():
    """Stop both motors immediately"""
    AIN1.value(0)
    AIN2.value(0)
    BIN1.value(0)
    BIN2.value(0)
    PWMA.duty_u16(0)
    PWMB.duty_u16(0)

def pid_line_following():
    """Main PID control function"""
    global previous_error, integral
    
    # Get current line position
    position = calculate_line_position()
    
    # Calculate error (setpoint is 2000 = center)
    error = 2000 - position
    
    # PID calculations
    proportional = error
    integral += error
    derivative = error - previous_error
    
    # Limit integral windup
    if integral > 5000:
        integral = 5000
    elif integral < -5000:
        integral = -5000
    
    # Calculate PID output
    pid_output = (KP * proportional) + (KI * integral) + (KD * derivative)
    
    # Calculate motor speeds
    left_speed = BASE_SPEED - pid_output
    right_speed = BASE_SPEED + pid_output
    
    # Ensure minimum speed for both motors
    if abs(left_speed) < MIN_SPEED:
        left_speed = MIN_SPEED if left_speed >= 0 else -MIN_SPEED
    if abs(right_speed) < MIN_SPEED:
        right_speed = MIN_SPEED if right_speed >= 0 else -MIN_SPEED
    
    # Apply motor speeds
    set_motor_speeds(left_speed, right_speed)
    
    # Store error for next iteration
    previous_error = error
    
    return error, position

def test_sensors():
    """Test all IR sensors"""
    print("Testing IR Sensors (Press Ctrl+C to stop)")
    try:
        while True:
            sensors = read_sensors()
            position = calculate_line_position()
            print(f"Sensors: {sensors} | Position: {position}")
            sleep(0.2)
    except KeyboardInterrupt:
        print("Sensor test stopped")

def test_motors():
    """Test motor functionality"""
    print("Testing Motors...")
    
    # Test forward movement
    print("Moving forward...")
    set_motor_speeds(15000, 15000)
    sleep(2)
    
    # Test left turn
    print("Turning left...")
    set_motor_speeds(8000, 20000)
    sleep(1)
    
    # Test right turn  
    print("Turning right...")
    set_motor_speeds(20000, 8000)
    sleep(1)
    
    # Stop
    print("Stopping...")
    stop_robot()

def main_menu():
    """Interactive menu system"""
    while True:
        print("\n" + "="*35)
        print("LINE FOLLOWING ROBOT CONTROL")
        print("="*35)
        print("1. Start Line Following")
        print("2. Test Sensors")
        print("3. Test Motors") 
        print("4. Stop Robot")
        print("5. Exit")
        print("="*35)
        
        try:
            choice = input("Select option (1-5): ")
            
            if choice == '1':
                start_line_following()
            elif choice == '2':
                test_sensors()
            elif choice == '3':
                test_motors()
            elif choice == '4':
                stop_robot()
                print("Robot stopped")
            elif choice == '5':
                stop_robot()
                print("Exiting...")
                break
            else:
                print("Invalid choice! Please select 1-5")
                
        except KeyboardInterrupt:
            stop_robot()
            print("\nProgram interrupted!")
            break

def start_line_following():
    """Start the main line following loop"""
    global previous_error, integral
    
    print("Starting Line Following Robot!")
    print("Press Ctrl+C to stop")
    
    # Reset PID variables
    previous_error = 0
    integral = 0
    
    try:
        while True:
            error, position = pid_line_following()
            
            # Optional: Print debug information
            sensors = read_sensors()
            print(f"Sensors: {sensors} | Pos: {position} | Error: {error:.1f}")
            
            sleep(0.02)  # 50Hz control loop
            
    except KeyboardInterrupt:
        stop_robot()
        print("\nLine following stopped!")

# Quick start function - uncomment to run immediately
def quick_start():
    """Start line following immediately without menu"""
    print("Quick Start - Line Following Robot")
    sleep(1)
    start_line_following()

# Main execution
if __name__ == "__main__":
    print("Line Following Robot Initialized")
    print("Hardware: Raspberry Pi Pico + TB6612FNG + 5 IR Sensors")
    
    # Choose startup mode:
    # Option 1: Interactive menu
    main_menu()
    
    # Option 2: Quick start (uncomment line below and comment line above)
    # quick_start()

