# Simple Line Follower Robot - Exact Pin Mapping
# Raspberry Pi Pico + TB6612FNG + 5 IR Sensors
# MicroPython for Thonny IDE

from machine import Pin, PWM
from utime import sleep

# IR Sensor Pin Mapping (Your exact connections)
IR_SENSOR_1 = Pin(2, Pin.IN)   # GP2 -> IR1 (Leftmost)
IR_SENSOR_2 = Pin(3, Pin.IN)   # GP3 -> IR2
IR_SENSOR_3 = Pin(4, Pin.IN)   # GP4 -> IR3 (Center)
IR_SENSOR_4 = Pin(5, Pin.IN)   # GP5 -> IR4
IR_SENSOR_5 = Pin(6, Pin.IN)   # GP6 -> IR5 (Rightmost)

# Motor Driver TB6612FNG Pin Mapping (Your exact connections)
LEFT_MOTOR_IN1 = Pin(10, Pin.OUT)    # GP10 -> AIN1
LEFT_MOTOR_IN2 = Pin(11, Pin.OUT)    # GP11 -> AIN2
LEFT_MOTOR_PWM = PWM(Pin(12))        # GP12 -> PWMA
RIGHT_MOTOR_IN1 = Pin(13, Pin.OUT)   # GP13 -> BIN1  
RIGHT_MOTOR_IN2 = Pin(14, Pin.OUT)   # GP14 -> BIN2
RIGHT_MOTOR_PWM = PWM(Pin(15))       # GP15 -> PWMB

# Set PWM frequency
LEFT_MOTOR_PWM.freq(1000)
RIGHT_MOTOR_PWM.freq(1000)

# PID Control Parameters
Kp = 20.0  # Proportional constant
Ki = 0.0   # Integral constant (start with 0)
Kd = 5.0   # Derivative constant

# Speed settings
BASE_SPEED = 18000      # Normal driving speed
MAX_CORRECTION = 10000  # Maximum correction value
MIN_SPEED = 5000       # Minimum motor speed

# Global PID variables
previous_error = 0
integral_error = 0

def read_all_sensors():
    """Read all 5 IR sensors and return their values"""
    sensor_values = [
        IR_SENSOR_1.value(),  # Leftmost
        IR_SENSOR_2.value(),
        IR_SENSOR_3.value(),  # Center
        IR_SENSOR_4.value(),
        IR_SENSOR_5.value()   # Rightmost
    ]
    return sensor_values

def calculate_error():
    """Calculate position error based on sensor readings"""
    sensors = read_all_sensors()
    
    # Define sensor positions (-2 to +2, where 0 is center)
    sensor_positions = [-2, -1, 0, 1, 2]
    
    # Calculate weighted average
    total_value = 0
    weighted_sum = 0
    
    for i, sensor in enumerate(sensors):
        if sensor == 1:  # Line detected (black line = 1, white surface = 0)
            weighted_sum += sensor_positions[i] * sensor
            total_value += sensor
    
    # If no line detected, maintain previous error
    if total_value == 0:
        return previous_error
    
    # Calculate position error
    line_position = weighted_sum / total_value
    return line_position

def motor_control(left_speed, right_speed):
    """Control both motors with given speeds"""
    
    # Limit speeds to safe range
    left_speed = max(0, min(35000, abs(left_speed)))
    right_speed = max(0, min(35000, abs(right_speed)))
    
    # Left Motor Control
    if left_speed > 0:
        LEFT_MOTOR_IN1.value(1)
        LEFT_MOTOR_IN2.value(0)
        LEFT_MOTOR_PWM.duty_u16(int(left_speed))
    else:
        LEFT_MOTOR_IN1.value(0)
        LEFT_MOTOR_IN2.value(0)
        LEFT_MOTOR_PWM.duty_u16(0)
    
    # Right Motor Control  
    if right_speed > 0:
        RIGHT_MOTOR_IN1.value(1)
        RIGHT_MOTOR_IN2.value(0)
        RIGHT_MOTOR_PWM.duty_u16(int(right_speed))
    else:
        RIGHT_MOTOR_IN1.value(0)
        RIGHT_MOTOR_IN2.value(0)
        RIGHT_MOTOR_PWM.duty_u16(0)

def stop_motors():
    """Emergency stop - turn off all motors"""
    LEFT_MOTOR_IN1.value(0)
    LEFT_MOTOR_IN2.value(0)
    RIGHT_MOTOR_IN1.value(0) 
    RIGHT_MOTOR_IN2.value(0)
    LEFT_MOTOR_PWM.duty_u16(0)
    RIGHT_MOTOR_PWM.duty_u16(0)

def pid_controller():
    """PID control algorithm for line following"""
    global previous_error, integral_error
    
    # Get current error
    current_error = calculate_error()
    
    # PID calculations
    proportional = current_error
    integral_error += current_error
    derivative = current_error - previous_error
    
    # Anti-windup for integral term
    if integral_error > 100:
        integral_error = 100
    elif integral_error < -100:
        integral_error = -100
    
    # Calculate PID output
    correction = (Kp * proportional) + (Ki * integral_error) + (Kd * derivative)
    
    # Limit correction
    if correction > MAX_CORRECTION:
        correction = MAX_CORRECTION
    elif correction < -MAX_CORRECTION:
        correction = -MAX_CORRECTION
    
    # Calculate motor speeds
    left_speed = BASE_SPEED + correction
    right_speed = BASE_SPEED - correction
    
    # Ensure minimum speed
    if left_speed < MIN_SPEED and left_speed > 0:
        left_speed = MIN_SPEED
    if right_speed < MIN_SPEED and right_speed > 0:
        right_speed = MIN_SPEED
    
    # Apply motor control
    motor_control(left_speed, right_speed)
    
    # Store error for next cycle
    previous_error = current_error
    
    return current_error, correction

def sensor_test():
    """Test IR sensors - shows sensor readings"""
    print("IR Sensor Test - Press Ctrl+C to stop")
    try:
        while True:
            sensors = read_all_sensors()
            error = calculate_error()
            print(f"Sensors: {sensors[0]}{sensors[1]}{sensors[2]}{sensors[3]}{sensors[4]} | Error: {error:.2f}")
            sleep(0.3)
    except KeyboardInterrupt:
        print("Sensor test stopped")

def motor_test():
    """Test motors - basic movement test"""
    print("Motor Test Starting...")
    
    print("Forward...")
    motor_control(15000, 15000)
    sleep(2)
    
    print("Left turn...")
    motor_control(8000, 20000)  
    sleep(1)
    
    print("Right turn...")
    motor_control(20000, 8000)
    sleep(1)
    
    print("Stop...")
    stop_motors()
    print("Motor test complete")

def line_following_mode():
    """Main line following function"""
    global previous_error, integral_error
    
    print("Line Following Started!")
    print("Place robot on line and press Enter to begin...")
    input()
    
    # Reset PID variables
    previous_error = 0
    integral_error = 0
    
    try:
        while True:
            # Run PID control
            error, correction = pid_controller()
            
            # Display status (optional - comment out for better performance)
            sensors = read_all_sensors()
            print(f"Sensors: {''.join(map(str, sensors))} | Error: {error:.2f} | Correction: {correction:.1f}")
            
            # Control loop delay
            sleep(0.02)  # 50Hz update rate
            
    except KeyboardInterrupt:
        stop_motors()
        print("Line following stopped!")

def main():
    """Main program with menu"""
    print("Line Following Robot - Ready!")
    print("Components: Pi Pico + TB6612FNG + 5 IR Sensors")
    
    while True:
        print("\n" + "="*30)
        print("ROBOT CONTROL MENU")
        print("="*30)
        print("1 - Start Line Following")
        print("2 - Test IR Sensors")
        print("3 - Test Motors")
        print("4 - Stop Motors")
        print("5 - Exit")
        print("="*30)
        
        try:
            choice = input("Choose option (1-5): ")
            
            if choice == '1':
                line_following_mode()
            elif choice == '2':
                sensor_test()
            elif choice == '3':
                motor_test()
            elif choice == '4':
                stop_motors()
                print("Motors stopped")
            elif choice == '5':
                stop_motors()
                print("Program ended")
                break
            else:
                print("Invalid choice - please select 1-5")
                
        except KeyboardInterrupt:
            stop_motors()
            print("\nProgram interrupted - motors stopped")
            break
        except Exception as e:
            stop_motors()
            print(f"Error: {e}")

# Run the program
if __name__ == "__main__":
    main()

# Alternative quick start (uncomment to skip menu):
# print("Quick Start Mode")
# sleep(2)
# line_following_mode()
